{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Next.js Frontend with TypeScript and Core Dependencies",
        "description": "Set up Next.js 14+ project with App Router, TypeScript, Tailwind CSS, and install core dependencies including Zustand, React Query, and Axios",
        "details": "Run `npx create-next-app@latest frontend --typescript --tailwind --app --no-src-dir` with the following configuration: TypeScript: Yes, ESLint: Yes, Tailwind CSS: Yes, App Router: Yes, Import alias: @/*. Install dependencies: `npm install zustand @tanstack/react-query axios`. Configure tailwind.config.ts for responsive design. Set up tsconfig.json with strict mode enabled. Create basic folder structure: /app (routes), /components (reusable UI), /lib (utilities), /stores (Zustand stores), /types (TypeScript interfaces). Configure next.config.js with image optimization and CORS settings for S3 integration.",
        "testStrategy": "Verify Next.js dev server starts successfully with `npm run dev`. Check that TypeScript compilation has no errors. Verify Tailwind CSS classes render correctly on a test page. Confirm all dependencies are installed in package.json with correct versions (Next.js 14+, React 18+, TypeScript 5+).",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Initialize Spring Boot Backend with AWS SDK and DynamoDB Configuration",
        "description": "Create Spring Boot 3.x project with Java 17+, configure AWS SDK v2 for S3 and DynamoDB, and set up REST API structure",
        "details": "Use Spring Initializr to create project with dependencies: Spring Web, Spring Boot DevTools, AWS SDK for Java v2 (S3 and DynamoDB). Add to pom.xml: `software.amazon.awssdk:s3`, `software.amazon.awssdk:dynamodb`, `software.amazon.awssdk:auth`. Create application.yml with AWS configuration: region (us-east-1), S3 bucket name, DynamoDB table names (Properties, Photos). Set up CORS configuration in WebConfig.java to allow Next.js frontend origin. Create package structure: /controllers (REST endpoints), /services (business logic), /models (DTOs and entities), /config (AWS clients), /repositories (DynamoDB access). Configure AWS credentials using DefaultCredentialsProvider or environment variables. Create S3Client and DynamoDbClient beans in AwsConfig.java.",
        "testStrategy": "Run Spring Boot application with `mvn spring-boot:run` and verify it starts without errors. Test AWS connectivity by calling S3 listBuckets() and DynamoDB listTables() in a test class. Verify CORS configuration allows requests from http://localhost:3000. Check application.yml loads correctly with all AWS properties.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement DynamoDB Table Creation and Data Access Layer",
        "description": "Create DynamoDB tables (Properties and Photos) and implement repository layer for CRUD operations",
        "details": "Create DynamoDB tables using AWS SDK or CDK: **Properties Table**: Partition Key: PropertyID (String), Attributes: Name (String), CreatedAt (String ISO8601), PhotoCount (Number). **Photos Table**: Partition Key: PhotoID (String), GSI: PropertyID-index with PropertyID as partition key, Attributes: Filename, S3Key, S3Bucket, UploadedAt, FileSize, Status, ContentType. Set both tables to On-Demand billing mode. Implement PropertyRepository.java with methods: createProperty(), getProperty(id), listProperties(), updatePhotoCount(). Implement PhotoRepository.java with methods: createPhoto(), getPhoto(id), listPhotosByProperty(propertyId), updatePhotoStatus(). Use DynamoDB Enhanced Client with @DynamoDbBean annotations for type-safe operations. Add error handling for conditional writes and item not found scenarios.",
        "testStrategy": "Write unit tests for each repository method using DynamoDB Local or Testcontainers. Test createProperty() inserts a record and verify with getProperty(). Test listPhotosByProperty() with GSI query returns correct photos. Verify updatePhotoCount() increments atomically. Test error handling for non-existent items.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and create DynamoDB table schemas with GSI for Photos table",
            "description": "Define and create DynamoDB table structures for Properties and Photos with proper partition keys, attributes, and Global Secondary Index configuration",
            "dependencies": [],
            "details": "Create Properties table with PropertyID (String) as partition key and attributes: Name (String), CreatedAt (String ISO8601), PhotoCount (Number). Create Photos table with PhotoID (String) as partition key and attributes: Filename, S3Key, S3Bucket, UploadedAt, FileSize, Status, ContentType. Add GSI named PropertyID-index with PropertyID as partition key for efficient querying by property. Configure both tables with On-Demand billing mode. Use AWS SDK v2 or CDK for table creation with proper IAM permissions.",
            "status": "pending",
            "testStrategy": "Verify tables are created successfully using AWS CLI describe-table commands. Confirm GSI is active and properly configured. Test write capacity with sample data insertion. Validate table schemas match specifications using automated schema validation tests."
          },
          {
            "id": 2,
            "title": "Implement PropertyRepository with CRUD methods using DynamoDB Enhanced Client",
            "description": "Create PropertyRepository.java with type-safe CRUD operations using DynamoDB Enhanced Client and @DynamoDbBean annotations",
            "dependencies": [
              1
            ],
            "details": "Create Property.java model class with @DynamoDbBean, @DynamoDbPartitionKey, and @DynamoDbAttribute annotations for PropertyID, Name, CreatedAt, PhotoCount. Implement PropertyRepository.java using DynamoDbEnhancedClient with methods: createProperty() to insert new property with generated UUID, getProperty(id) to retrieve by partition key, listProperties() with scan operation and sorting by CreatedAt DESC, updatePhotoCount(propertyId, increment) using UpdateExpression for atomic increment. Configure DynamoDbTable<Property> bean injection.",
            "status": "pending",
            "testStrategy": "Write unit tests using DynamoDB Local or Testcontainers. Test createProperty() inserts record and verify retrieval with getProperty(). Test listProperties() returns items sorted correctly. Verify updatePhotoCount() increments atomically using concurrent updates. Test getProperty() returns null for non-existent ID."
          },
          {
            "id": 3,
            "title": "Implement PhotoRepository with basic CRUD operations",
            "description": "Create PhotoRepository.java with CRUD methods for photo metadata management using DynamoDB Enhanced Client",
            "dependencies": [
              1
            ],
            "details": "Create Photo.java model class with @DynamoDbBean annotations for PhotoID (partition key), PropertyID, Filename, S3Key, S3Bucket, UploadedAt, FileSize, Status, ContentType. Add @DynamoDbSecondaryPartitionKey annotation on PropertyID for GSI. Implement PhotoRepository.java with methods: createPhoto() to insert photo metadata, getPhoto(id) to retrieve by PhotoID, updatePhotoStatus(photoId, status) to update Status field using conditional writes, deletePhoto(id) for removal. Use DynamoDbEnhancedClient with type-safe operations and proper exception handling.",
            "status": "pending",
            "testStrategy": "Write unit tests with DynamoDB Local. Test createPhoto() inserts complete metadata and verify with getPhoto(). Test updatePhotoStatus() changes status correctly. Verify conditional write failures throw proper exceptions. Test deletePhoto() removes item successfully. Validate all attribute mappings are correct."
          },
          {
            "id": 4,
            "title": "Implement GSI query for listPhotosByProperty with proper pagination",
            "description": "Add listPhotosByProperty method to PhotoRepository using GSI query with pagination support for efficient photo retrieval by property",
            "dependencies": [
              3
            ],
            "details": "Implement listPhotosByProperty(propertyId, limit, exclusiveStartKey) method using PropertyID-index GSI. Create QueryEnhancedRequest with keyEqualTo(PropertyID) condition and optional limit parameter. Return PagedResponse object containing List<Photo> and lastEvaluatedKey for pagination. Add sorting by UploadedAt if needed using sort key on GSI. Implement helper method to handle pagination token serialization/deserialization. Set default page size to 50, maximum 100. Handle empty results gracefully.",
            "status": "pending",
            "testStrategy": "Test query returns only photos for specified propertyId. Insert 150 photos across 3 properties and verify pagination works with multiple pages. Test lastEvaluatedKey allows fetching next page correctly. Verify query performance with 1000+ photos using CloudWatch metrics. Test empty property returns empty list without errors."
          },
          {
            "id": 5,
            "title": "Add comprehensive error handling for conditional writes, item not found, and throughput exceptions",
            "description": "Implement robust error handling across both repositories for DynamoDB-specific exceptions with proper logging and user-friendly error messages",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create custom exceptions: PropertyNotFoundException, PhotoNotFoundException, ConditionalCheckFailedException wrapping DynamoDB exceptions. Add try-catch blocks in all repository methods to handle: ConditionalCheckFailedException for failed conditional writes, ResourceNotFoundException for non-existent items, ProvisionedThroughputExceededException with exponential backoff retry logic (max 3 retries), ValidationException for invalid input. Implement logging using SLF4J with appropriate log levels (ERROR for exceptions, INFO for operations). Add @ControllerAdvice exception handler to map exceptions to HTTP status codes (404 for not found, 409 for conditional check failures, 503 for throughput exceeded).",
            "status": "pending",
            "testStrategy": "Write unit tests to simulate ConditionalCheckFailedException and verify custom exception is thrown. Test item not found scenarios return 404. Simulate throughput exceeded with rate limiting and verify retry logic executes. Test validation errors return 400 status. Verify all exceptions are logged with correlation IDs for tracing."
          }
        ]
      },
      {
        "id": 4,
        "title": "Implement Backend REST API Endpoints for Property Management",
        "description": "Create REST controllers and services for property creation, retrieval, and listing",
        "details": "Create PropertyController.java with endpoints: `POST /api/properties` (create new property with request body {name: string}), `GET /api/properties` (list all properties, sorted by createdAt DESC), `GET /api/properties/{id}` (get single property with photo count), `GET /api/properties/{id}/photos` (list photos for property). Create PropertyService.java to handle business logic: generate UUID for PropertyID, validate name (required, max 200 chars), set CreatedAt timestamp, initialize PhotoCount to 0. Return DTOs with proper JSON serialization. Implement pagination for list endpoints (limit 50 properties per page). Add request validation using @Valid and @NotBlank annotations. Configure Jackson for ISO8601 date serialization.",
        "testStrategy": "Write integration tests using @SpringBootTest and MockMvc. Test POST /api/properties returns 201 with propertyId. Test GET /api/properties returns array sorted by date. Test GET /api/properties/{id} returns 404 for non-existent property. Use Postman or curl to manually test all endpoints. Verify JSON response structure matches API specification in PRD.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement S3 Pre-signed URL Generation and Photo Upload Confirmation Endpoints",
        "description": "Create REST endpoints for generating S3 pre-signed URLs and confirming successful uploads",
        "details": "Create PhotoController.java with endpoints: `POST /api/photos/presigned-url` (request body: {propertyId, filename, contentType, fileSize}), `POST /api/photos/confirm` (request body: {photoId, propertyId, s3Key}), `GET /api/photos/{id}` (get photo metadata). Create S3Service.java with method generatePresignedUrl(): generate UUID for photoId, construct S3 key as `properties/{propertyId}/{photoId}-{sanitized-filename}`, create PutObjectRequest with contentType, use S3Presigner to generate presigned URL with 15-minute expiration, return {photoId, uploadUrl, expiresIn, fields: {key}}. Implement PhotoService.confirmUpload(): validate photoId exists in pending state, update Photos table with status='uploaded', increment PropertyPhotoCount in Properties table, return photo URL (S3 bucket URL or CloudFront if configured). Sanitize filenames to remove special characters and prevent path traversal.",
        "testStrategy": "Test presigned URL generation returns valid URL that expires in 900 seconds. Use Postman to upload a test file directly to S3 using the presigned URL. Verify confirmUpload() updates DynamoDB with correct metadata. Test error handling for invalid propertyId or duplicate photoId. Write integration test that simulates complete upload flow: request URL → upload to S3 → confirm → verify photo appears in property.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create PhotoController with POST /api/photos/presigned-url endpoint and input validation",
            "description": "Implement the REST controller for handling presigned URL requests with comprehensive input validation for propertyId, filename, contentType, and fileSize parameters",
            "dependencies": [],
            "details": "Create PhotoController.java in the controller package. Implement POST /api/photos/presigned-url endpoint with @PostMapping annotation. Define request DTO (PresignedUrlRequest) with fields: propertyId (String, required), filename (String, required, max 255 chars), contentType (String, required, must match allowed types: image/jpeg, image/png, image/heic), fileSize (Long, required, max 50MB). Add @Valid annotation and Bean Validation constraints (@NotNull, @Size, @Pattern). Implement validation logic to check propertyId exists in DynamoDB. Return PresignedUrlResponse with photoId, uploadUrl, expiresIn, and fields object. Add proper error handling with @ExceptionHandler for validation failures returning 400 Bad Request.",
            "status": "pending",
            "testStrategy": "Write unit tests with MockMvc to verify endpoint accepts valid requests and returns 200 with correct response structure. Test validation rejects missing fields, invalid contentType, fileSize exceeding limit, and non-existent propertyId. Verify response contains valid UUID photoId and uploadUrl starts with https://. Use @WebMvcTest for controller layer testing."
          },
          {
            "id": 2,
            "title": "Implement S3Service.generatePresignedUrl with S3Presigner configuration and secure key generation",
            "description": "Create S3Service with presigned URL generation logic using AWS S3Presigner, including UUID-based photoId generation and secure S3 key construction",
            "dependencies": [
              1
            ],
            "details": "Create S3Service.java with @Service annotation. Configure S3Presigner bean in AWS configuration class with region and credentials from application.properties. Implement generatePresignedUrl(String propertyId, String filename, String contentType, Long fileSize) method. Generate UUID for photoId using UUID.randomUUID(). Construct S3 key as `properties/{propertyId}/{photoId}-{sanitizedFilename}` (sanitization handled in subtask 3). Create PutObjectRequest with bucket name from config, S3 key, contentType metadata, and content-length. Use S3Presigner.presignPutObject() with 15-minute expiration (Duration.ofMinutes(15)). Return PresignedUrlResponse DTO containing photoId, presigned URL string, expiresIn seconds (900), and fields map with key. Add logging for presigned URL generation events.",
            "status": "pending",
            "testStrategy": "Write unit tests using Mockito to mock S3Presigner. Verify generatePresignedUrl returns valid URL structure matching S3 presigned URL format. Test that photoId is valid UUID format. Verify S3 key follows correct pattern with propertyId and photoId. Test expiration is set to 900 seconds. Write integration test with actual S3Presigner (using LocalStack or AWS testcontainers) to generate URL and verify it can be used for PUT request."
          },
          {
            "id": 3,
            "title": "Add filename sanitization utility to prevent path traversal and handle special characters",
            "description": "Implement utility class for secure filename sanitization that removes path traversal attempts, special characters, and handles Unicode filenames safely",
            "dependencies": [],
            "details": "Create FileUtils.java or FilenameValidator.java utility class. Implement sanitizeFilename(String filename) method that: removes path traversal sequences (../, .\\, absolute paths), strips leading/trailing whitespace and dots, replaces special characters (except alphanumeric, dash, underscore, dot) with underscores, preserves file extension, handles Unicode characters by normalizing to NFC form, limits length to 100 characters (excluding extension), prevents empty filenames by returning 'file' default. Handle edge cases: null input (throw IllegalArgumentException), filenames with only special chars (return 'file.ext'), multiple extensions (keep only last one). Add comprehensive JavaDoc explaining security considerations. Make method static and thread-safe.",
            "status": "pending",
            "testStrategy": "Write comprehensive unit tests covering: path traversal attempts ('../../../etc/passwd' becomes 'etcpasswd'), special characters ('my@file!.jpg' becomes 'my_file_.jpg'), Unicode filenames (preserve valid characters), very long filenames (truncate to 100 chars), edge cases (null, empty, only dots/spaces). Test that file extensions are preserved correctly. Verify no path separators (/ or \\) remain in output. Test thread safety with concurrent execution."
          },
          {
            "id": 4,
            "title": "Implement POST /api/photos/confirm endpoint with transaction support",
            "description": "Create REST endpoint for confirming successful S3 uploads with atomic transaction support to ensure data consistency across Photos and Properties tables",
            "dependencies": [
              1
            ],
            "details": "Add POST /api/photos/confirm endpoint to PhotoController.java. Define ConfirmUploadRequest DTO with fields: photoId (String, required, UUID format), propertyId (String, required, UUID format), s3Key (String, required, matches pattern 'properties/{propertyId}/{photoId}-*'). Validate s3Key matches expected pattern to prevent malicious key injection. Implement @Transactional annotation for ACID guarantees. Call PhotoService.confirmUpload() to handle business logic. Return ConfirmUploadResponse with photoUrl (S3 bucket URL: https://{bucket}.s3.{region}.amazonaws.com/{s3Key} or CloudFront URL if configured), photoId, and status. Add validation to ensure propertyId in request matches propertyId extracted from s3Key. Implement error handling for: photoId not found (404), photo already confirmed (409 conflict), propertyId mismatch (400), transaction failures (500 with retry indication).",
            "status": "pending",
            "testStrategy": "Write integration tests with @SpringBootTest and TestEntityManager. Test successful confirmation updates photo status and increments property count atomically. Test idempotency by confirming same photo twice (should return 409). Test validation rejects mismatched propertyId between request body and s3Key. Test non-existent photoId returns 404. Simulate transaction failure and verify rollback occurs (neither photo status nor count updated). Verify photoUrl format is correct."
          },
          {
            "id": 5,
            "title": "Create PhotoService.confirmUpload with DynamoDB status update and atomic counter increment",
            "description": "Implement service layer business logic for upload confirmation including atomic DynamoDB operations to update Photos status and increment Properties photo count",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create PhotoService.java with @Service annotation. Implement confirmUpload(String photoId, String propertyId, String s3Key) method. First, query Photos table by photoId to verify it exists and is in 'pending' status (status field should be created during presigned URL generation). If not pending, throw PhotoAlreadyConfirmedException. Construct UpdateItemRequest for Photos table: set Status='uploaded', UploadedAt=current ISO8601 timestamp, S3Key=s3Key value, add condition expression 'attribute_exists(PhotoID) AND #status = :pending' to prevent race conditions. Execute DynamoDB transactWriteItems with two operations: (1) UpdateItem on Photos table to set status='uploaded', (2) UpdateItem on Properties table to atomically increment PhotoCount using 'ADD PhotoCount :inc' with :inc=1. If transaction fails due to condition check, throw appropriate exception. Extract S3 bucket from configuration and construct photoUrl. Return ConfirmUploadResponse. Add proper logging and metrics.",
            "status": "pending",
            "testStrategy": "Write unit tests with mocked DynamoDB client. Verify confirmUpload constructs correct UpdateItemRequest with condition expression. Test atomic transaction includes both Photos update and Properties count increment. Test condition check failure when photo not in pending status throws PhotoAlreadyConfirmedException. Write integration test with DynamoDB Local to verify actual atomic increment works correctly. Test race condition scenario with concurrent confirmUpload calls for same photoId (only one should succeed). Verify PhotoCount increments correctly across multiple uploads."
          },
          {
            "id": 6,
            "title": "Add comprehensive error handling for S3 errors, expired URLs, and race conditions",
            "description": "Implement centralized exception handling and error recovery mechanisms for S3-related failures, presigned URL expiration, and concurrent upload race conditions",
            "dependencies": [
              5
            ],
            "details": "Create custom exception classes: PresignedUrlExpiredException, S3UploadFailedException, PhotoAlreadyConfirmedException, PropertyNotFoundException, InvalidS3KeyException. Implement @ControllerAdvice class (GlobalExceptionHandler.java) with @ExceptionHandler methods for each custom exception, returning appropriate HTTP status codes and error response DTOs (ErrorResponse with timestamp, status, error, message, path). Handle AWS SDK exceptions: catch SdkException from S3Presigner and map to user-friendly errors, catch ConditionalCheckFailedException from DynamoDB for race conditions (return 409 Conflict), catch ResourceNotFoundException for missing records (return 404). Implement retry logic in S3Service using @Retryable annotation (max 3 attempts, exponential backoff) for transient S3 errors. Add circuit breaker pattern using Resilience4j for S3 presigner calls to prevent cascading failures. Log all exceptions with correlation IDs for tracing. Add metrics/counters for each error type using Micrometer.",
            "status": "pending",
            "testStrategy": "Write unit tests for each exception handler verifying correct HTTP status and error message format. Test retry logic by simulating transient S3 failures (verify 3 retry attempts with exponential backoff). Test circuit breaker opens after threshold failures and prevents further S3 calls. Integration test: simulate expired presigned URL by setting very short expiration and verify appropriate error returned. Test race condition handling by concurrent confirmUpload calls (verify one succeeds with 200, others fail with 409). Verify all error responses include correlation ID for tracing."
          }
        ]
      },
      {
        "id": 6,
        "title": "Build Frontend Property Management UI and API Integration",
        "description": "Create property creation form, property list view, and integrate with backend API using React Query",
        "details": "Create components: PropertyForm.tsx (modal with name input, max 200 chars validation, submit button), PropertyList.tsx (displays properties with name, createdAt, photoCount in card grid), PropertySelector.tsx (dropdown or list for selecting active property). Create /lib/api.ts with Axios instance configured for backend base URL (http://localhost:8080/api). Implement React Query hooks in /lib/hooks/useProperties.ts: useCreateProperty (mutation), useProperties (query with refetch), usePropertyPhotos (query). Create Zustand store /stores/propertyStore.ts to manage selected property state. Create pages: /app/page.tsx (landing page with PropertyList and \"Create Property\" button), /app/properties/[id]/page.tsx (property detail view with photo gallery). Style with Tailwind CSS using responsive grid (grid-cols-1 md:grid-cols-3). Add loading states, error handling, and optimistic updates for mutations.",
        "testStrategy": "Test property creation form submits and displays in list immediately. Verify React Query caches property list and refetches after mutations. Test property selection updates Zustand store. Test responsive design at mobile (375px), tablet (768px), and desktop (1920px) breakpoints. Verify error messages display for failed API calls. Test with React DevTools to confirm state management works correctly.",
        "priority": "high",
        "dependencies": [
          4
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Axios API client with base URL and error interceptors",
            "description": "Create /lib/api.ts file with Axios instance configured for backend communication, including base URL configuration and error handling interceptors",
            "dependencies": [],
            "details": "Create /lib/api.ts with Axios instance configured with base URL (http://localhost:8080/api). Add request interceptor to include headers if needed. Add response interceptor to handle common errors (401, 403, 500) and transform error responses into user-friendly messages. Export configured Axios instance for use in React Query hooks. Include TypeScript types for API error responses.",
            "status": "pending",
            "testStrategy": "Test API client makes requests to correct base URL. Verify error interceptor catches 4xx and 5xx errors and formats them correctly. Test with mock backend responses."
          },
          {
            "id": 2,
            "title": "Create React Query hooks for property operations",
            "description": "Implement React Query hooks in /lib/hooks/useProperties.ts including useCreateProperty mutation, useProperties query, and usePropertyPhotos query with proper cache management",
            "dependencies": [
              1
            ],
            "details": "Create /lib/hooks/useProperties.ts with three hooks: useCreateProperty (useMutation for POST /properties with onSuccess invalidating properties query), useProperties (useQuery for GET /properties with refetchOnWindowFocus), usePropertyPhotos (useQuery for GET /properties/:id/photos with propertyId parameter). Configure React Query client with proper staleTime and cacheTime. Add TypeScript interfaces for Property and Photo types. Include proper error handling for each hook.",
            "status": "pending",
            "testStrategy": "Test useProperties fetches and caches property list. Verify useCreateProperty mutation invalidates cache and triggers refetch. Test usePropertyPhotos fetches photos for specific property. Verify cache management works correctly."
          },
          {
            "id": 3,
            "title": "Implement PropertyForm component with validation and modal behavior",
            "description": "Create PropertyForm.tsx component as a modal with form validation for property name input, submit handling, and proper error states",
            "dependencies": [
              2
            ],
            "details": "Create /components/PropertyForm.tsx as a modal component with controlled form input for property name. Implement validation: max 200 characters, required field. Use React Hook Form or native state management for form handling. Add submit button with loading state during mutation. Display error messages below input field. Style with Tailwind CSS using modal overlay, centered card, and responsive design. Include close button and ESC key handler. Integrate with useCreateProperty hook for submission.",
            "status": "pending",
            "testStrategy": "Test form validates name length (reject >200 chars). Verify required field validation. Test modal opens and closes correctly. Verify form submits and shows loading state. Test error messages display on validation failure and API errors."
          },
          {
            "id": 4,
            "title": "Create PropertyList component with responsive grid layout",
            "description": "Build PropertyList.tsx component displaying properties in a responsive card grid with property name, creation date, and photo count using Tailwind CSS",
            "dependencies": [
              2
            ],
            "details": "Create /components/PropertyList.tsx that uses useProperties hook to fetch and display properties. Implement responsive grid layout using Tailwind: grid-cols-1 md:grid-cols-2 lg:grid-cols-3. Create property card component showing name, formatted createdAt date, and photoCount. Add loading skeleton for initial load state. Display error message if query fails. Add empty state when no properties exist. Include click handler to navigate to property detail page. Style cards with hover effects and shadows.",
            "status": "pending",
            "testStrategy": "Test component displays properties in grid correctly. Verify responsive layout at 375px, 768px, and 1920px viewports. Test loading state shows skeletons. Verify error state displays message. Test empty state when no properties exist. Verify click navigation works."
          },
          {
            "id": 5,
            "title": "Build PropertySelector component with Zustand integration",
            "description": "Create PropertySelector.tsx component and /stores/propertyStore.ts Zustand store for managing selected property state across the application",
            "dependencies": [
              2
            ],
            "details": "Create /stores/propertyStore.ts with Zustand store containing: selectedPropertyId (string|null), setSelectedProperty(id: string), clearSelectedProperty(). Add localStorage persistence for selected property. Create /components/PropertySelector.tsx as dropdown/select component that fetches properties using useProperties hook and displays them as options. On selection, update Zustand store. Show current selected property. Style with Tailwind CSS as a styled select or custom dropdown. Handle empty state when no properties exist.",
            "status": "pending",
            "testStrategy": "Test Zustand store updates selectedPropertyId correctly. Verify localStorage persists selection across page refreshes. Test PropertySelector component displays all properties. Verify selection updates store. Test component handles no properties gracefully."
          },
          {
            "id": 6,
            "title": "Implement optimistic updates, loading states, and error handling",
            "description": "Add optimistic updates to property mutations, comprehensive loading states, and error handling across all property management components",
            "dependencies": [
              3,
              4,
              5
            ],
            "details": "Implement optimistic updates in useCreateProperty: update query cache immediately on mutation start, rollback on error. Add loading states to all components: PropertyForm (submit button disabled during mutation), PropertyList (skeleton cards during fetch), PropertySelector (loading spinner). Create error boundary component to catch React errors. Add toast notifications for success/error messages using a library like react-hot-toast. Implement retry logic in React Query for failed requests. Add global error handling for network failures. Ensure all error messages are user-friendly.",
            "status": "pending",
            "testStrategy": "Test optimistic update adds property to list immediately before API response. Verify rollback on API error. Test all loading states display correctly. Simulate network errors and verify error messages show. Test retry logic attempts failed requests. Verify toast notifications appear for success and errors."
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement Frontend Upload Queue Manager with Concurrent Upload Logic",
        "description": "Create Zustand store for upload queue management with concurrent upload orchestration, progress tracking, and retry logic",
        "details": "Create /stores/uploadStore.ts with Zustand store structure: {queue: Photo[], selectedPropertyId: string, uploadStatus: Map<photoId, {progress: number, status: 'queued'|'uploading'|'complete'|'failed', error?: string}>}. Implement actions: addPhotosToQueue(files: File[]), startUpload(), cancelUpload(photoId), retryUpload(photoId), clearCompleted(). Create /lib/uploadManager.ts with concurrent upload logic: use Promise.allSettled() to handle concurrent uploads (default concurrency: 20, configurable up to 1000), implement exponential backoff retry (3 attempts with 1s, 2s, 4s delays), use XMLHttpRequest for progress events (track upload.onprogress), handle errors and update status. For each photo: (1) Request presigned URL from backend, (2) Upload to S3 using PUT with progress tracking, (3) Call confirm endpoint on success, (4) Update store with status. Persist queue state to localStorage on changes and restore on app load. Implement queue processing with configurable concurrency limit using a semaphore pattern.",
        "testStrategy": "Write unit tests for uploadStore actions (add, start, cancel, retry). Test concurrent upload manager with mock 100 files and verify concurrency limit works. Simulate network failures and verify retry logic executes 3 times. Test localStorage persistence by refreshing page mid-upload. Test progress tracking updates store correctly (0-100%). Use browser DevTools Network tab throttled to 3G to verify progress events fire correctly. Verify memory cleanup after uploads complete.",
        "priority": "high",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Zustand uploadStore schema with queue, status map, and actions",
            "description": "Create the Zustand store structure in /stores/uploadStore.ts with type definitions for the queue, upload status tracking, and all necessary action methods",
            "dependencies": [],
            "details": "Define TypeScript interfaces: Photo type, UploadStatus type with progress/status/error fields, UploadStore interface. Create Zustand store with state: {queue: Photo[], selectedPropertyId: string, uploadStatus: Map<string, UploadStatus>}. Define action signatures: addPhotosToQueue(files: File[]), startUpload(), cancelUpload(photoId: string), retryUpload(photoId: string), clearCompleted(). Ensure type safety and proper state immutability patterns.",
            "status": "pending",
            "testStrategy": "Write unit tests verifying store initialization, action method signatures, and type correctness. Test that state updates are immutable and actions are properly bound."
          },
          {
            "id": 2,
            "title": "Implement semaphore/concurrency limiter for controlling parallel uploads",
            "description": "Create a semaphore pattern implementation to limit concurrent uploads from 1 to 1000 configurable connections",
            "dependencies": [
              1
            ],
            "details": "Create /lib/concurrencyLimiter.ts with Semaphore class that manages a pool of available slots. Implement acquire() method that returns a promise resolving when a slot is available, and release() method to free slots. Add configurable maxConcurrency parameter (default: 20, max: 1000). Use queue pattern with promise resolvers to handle waiting tasks. Ensure thread-safety and proper cleanup on errors.",
            "status": "pending",
            "testStrategy": "Test semaphore with mock async tasks. Verify only N tasks run concurrently where N is the limit. Test with limits of 1, 20, 100, and 1000. Verify queued tasks start when slots become available and proper cleanup on errors."
          },
          {
            "id": 3,
            "title": "Create upload orchestration logic with Promise.allSettled and queue processing",
            "description": "Implement the main upload orchestration in /lib/uploadManager.ts that processes the queue with concurrency control using Promise.allSettled",
            "dependencies": [
              1,
              2
            ],
            "details": "Create UploadManager class with processQueue() method. Use semaphore to control concurrency. For each photo in queue: acquire semaphore slot, create upload promise, track in-flight uploads. Use Promise.allSettled() to handle all uploads and capture successes/failures independently. Update uploadStore status as uploads progress. Implement proper cleanup and slot release on completion/error. Handle edge cases like empty queue and all failed uploads.",
            "status": "pending",
            "testStrategy": "Test orchestration with mock 100 files and verify concurrency limit respected. Simulate mixed success/failure scenarios and verify Promise.allSettled handles independently. Test queue processing completes all items and updates store correctly."
          },
          {
            "id": 4,
            "title": "Implement XMLHttpRequest-based S3 upload with progress tracking",
            "description": "Create XMLHttpRequest upload function with progress event tracking for real-time upload status updates",
            "dependencies": [
              1
            ],
            "details": "In /lib/uploadManager.ts, create uploadToS3() function accepting presigned URL, file, and photoId. Use XMLHttpRequest instead of fetch for progress events. Implement upload.onprogress handler to calculate percentage and update uploadStore. Handle upload.onload for success, upload.onerror for failures, upload.onabort for cancellations. Use PUT method with proper Content-Type headers. Return promise that resolves/rejects based on upload outcome. Store AbortController reference for cancellation support.",
            "status": "pending",
            "testStrategy": "Test upload with mock files and verify progress events fire correctly. Test progress calculation accuracy (0-100%). Verify success/error/abort handlers update store appropriately. Test cancellation via AbortController works mid-upload."
          },
          {
            "id": 5,
            "title": "Add exponential backoff retry logic with 3 attempts and configurable delays",
            "description": "Implement retry mechanism with exponential backoff for failed uploads, attempting up to 3 times with 1s, 2s, 4s delays",
            "dependencies": [
              3,
              4
            ],
            "details": "Create retryWithBackoff() utility function in /lib/uploadManager.ts. Accept async operation, maxRetries (default: 3), and base delay (default: 1000ms). Implement exponential backoff: delay = baseDelay * (2 ^ attemptNumber). Wrap upload operations with retry logic. Update uploadStore with attempt count and last error. Only retry on network errors, not 4xx client errors. Implement configurable retry strategy. Handle max retries exceeded by marking upload as permanently failed.",
            "status": "pending",
            "testStrategy": "Simulate network failures and verify retry executes exactly 3 times with correct delays (1s, 2s, 4s). Test that 4xx errors don't trigger retries. Verify store shows attempt count. Test successful retry updates status to complete."
          },
          {
            "id": 6,
            "title": "Implement localStorage persistence and queue restoration on app load",
            "description": "Add localStorage sync for upload queue state and restore functionality on application initialization",
            "dependencies": [
              1
            ],
            "details": "In uploadStore.ts, implement middleware to sync state changes to localStorage using 'uploadQueue' key. Serialize queue and uploadStatus Map to JSON. On store initialization, check localStorage for persisted state and restore queue/status. Handle version compatibility and corrupted data gracefully. Debounce localStorage writes to avoid excessive I/O (300ms delay). Implement clearPersistedState() for cleanup. Restore only pending/uploading items, filter out completed uploads older than 24 hours.",
            "status": "pending",
            "testStrategy": "Test localStorage persistence by adding items to queue and verifying localStorage contains correct data. Refresh page mid-upload and verify queue restored. Test with corrupted localStorage data and verify graceful handling. Verify debouncing limits write frequency."
          },
          {
            "id": 7,
            "title": "Add comprehensive error handling, memory cleanup, and abort controller for cancellation",
            "description": "Implement robust error handling, memory leak prevention, and upload cancellation infrastructure across the upload system",
            "dependencies": [
              3,
              4,
              5,
              6
            ],
            "details": "Add try-catch blocks around all async operations with specific error types (NetworkError, S3Error, ValidationError). Implement memory cleanup: revoke Object URLs after upload, clear completed uploads from memory, limit queue size (max 10000 items). Create AbortController map keyed by photoId for cancellation. Implement cancelUpload() to abort XMLHttpRequest and clean up resources. Add cleanup on component unmount. Implement error boundaries and fallback UI. Log errors to console/service. Handle edge cases: browser offline, storage quota exceeded, invalid files.",
            "status": "pending",
            "testStrategy": "Test cancelUpload() aborts in-flight requests and cleans resources. Verify no memory leaks with 1000 upload cycle using Chrome DevTools. Test error handling for network offline, invalid presigned URLs, and file read errors. Verify cleanup on unmount prevents orphaned uploads."
          }
        ]
      },
      {
        "id": 8,
        "title": "Build Upload Interface with Real-time Progress Tracking and Error Handling",
        "description": "Create upload UI components with file selection, queue visualization, individual/batch progress bars, and retry functionality",
        "details": "Create components: FileUploadButton.tsx (file input with multi-select, max 1000 files, accept=\"image/*\"), UploadQueue.tsx (displays all photos in queue with status badges), UploadProgressItem.tsx (individual photo with filename, size, progress bar, status icon, retry button), BatchProgress.tsx (overall progress: \"47/1000 uploaded\", estimated time remaining). Create /app/upload/page.tsx main upload interface: property selector at top, file upload button, batch progress summary, scrollable queue list with virtualization (react-window for 1000+ items). Implement drag-and-drop support for file selection. Use Tailwind for status indicators: gray (queued), blue (uploading), green (complete), red (failed). Add cancel button for in-progress uploads, retry button for failed (shows after 3 auto-retries exhausted). Show error messages on hover/click for failed photos. Add \"Clear Completed\" button to remove successful uploads from view. Implement success modal when all uploads complete with link to gallery.",
        "testStrategy": "Test file selection with 10, 100, and 1000 photos. Verify queue renders efficiently with 1000 items (use React DevTools Profiler). Test progress bars update smoothly during upload. Simulate failures and verify retry button appears and works. Test cancel functionality stops upload mid-progress. Verify drag-and-drop adds files to queue. Test on Chrome, Safari, and Edge browsers. Check UI remains responsive during uploads (60 FPS in DevTools Performance tab).",
        "priority": "high",
        "dependencies": [
          7
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create FileUploadButton with multi-select file input and drag-and-drop support",
            "description": "Build the FileUploadButton.tsx component with multi-select file input (max 1000 files, accept='image/*') and implement drag-and-drop functionality for file selection",
            "dependencies": [],
            "details": "Create FileUploadButton.tsx component with input type='file' element with multiple attribute and accept='image/*'. Implement drag-and-drop handlers (onDragEnter, onDragOver, onDragLeave, onDrop) with visual feedback (border highlight). Add file validation: check file count <= 1000, verify MIME types are images, show error toast for invalid files. Style with Tailwind: dashed border, hover states, drag-active state. Emit onChange event with validated File[] array to parent component.",
            "status": "pending",
            "testStrategy": "Test file selection dialog with 10, 100, and 1000 images. Test drag-and-drop with multiple files and verify visual feedback appears. Test file type validation rejects non-image files. Verify error messages show when exceeding 1000 file limit. Test keyboard accessibility (Enter/Space to trigger file dialog)."
          },
          {
            "id": 2,
            "title": "Implement UploadProgressItem component with progress bar, status indicators, and retry button",
            "description": "Create UploadProgressItem.tsx component displaying individual photo upload progress with filename, file size, animated progress bar, status icons, and conditional retry button",
            "dependencies": [],
            "details": "Create UploadProgressItem.tsx accepting props: {photoId, filename, size, progress: number (0-100), status: 'queued'|'uploading'|'complete'|'failed', error?: string, onRetry, onCancel}. Display filename (truncate long names with ellipsis), formatted file size (KB/MB). Implement progress bar with Tailwind transition-all for smooth animation. Add status badge with color coding: gray (queued), blue pulsing (uploading), green checkmark (complete), red X (failed). Show retry button only when status='failed' and auto-retry count exhausted. Add cancel button for 'uploading' status. Implement error tooltip on hover for failed items.",
            "status": "pending",
            "testStrategy": "Test component renders correctly for all status states (queued, uploading, complete, failed). Verify progress bar animates smoothly from 0-100%. Test retry button only appears for failed status. Test cancel button works during upload. Verify error tooltip displays on hover. Test filename truncation with very long filenames."
          },
          {
            "id": 3,
            "title": "Build BatchProgress component with overall statistics and time estimation",
            "description": "Create BatchProgress.tsx component showing aggregate upload statistics including completed count, total count, overall progress percentage, and estimated time remaining",
            "dependencies": [],
            "details": "Create BatchProgress.tsx component accepting props: {totalCount, completedCount, failedCount, inProgressCount, avgUploadSpeed: bytes/sec}. Display statistics: 'X/Y uploaded' with color-coded counts, overall progress bar showing percentage, failed count in red if > 0. Implement ETA calculation: estimatedSeconds = (remainingBytes / avgUploadSpeed), format as 'About X minutes remaining' or 'Less than a minute'. Calculate avgUploadSpeed from last 10 completed uploads using sliding window. Show upload speed in MB/s. Add pause/resume all button. Style with Tailwind card layout with shadow and rounded corners.",
            "status": "pending",
            "testStrategy": "Test ETA calculation accuracy with mock upload speeds. Verify progress bar updates correctly as uploads complete. Test display with edge cases: 0 uploads, all failed, all complete. Verify speed calculation updates every few seconds. Test pause/resume functionality affects all uploads. Check responsive layout on mobile devices."
          },
          {
            "id": 4,
            "title": "Create virtualized UploadQueue using react-window for efficient rendering of 1000+ items",
            "description": "Build UploadQueue.tsx component with react-window virtualization to efficiently render and display 1000+ photos in the upload queue without performance degradation",
            "dependencies": [
              2
            ],
            "details": "Create UploadQueue.tsx using react-window's VariableSizeList component. Install react-window: 'npm install react-window @types/react-window'. Configure list with height=600px, itemCount=queue.length, overscanCount=5 for smooth scrolling. Render UploadProgressItem in each row with index-based data lookup. Implement dynamic row height calculation based on content (collapsed: 60px, expanded with error: 100px). Add scroll-to-failed functionality to jump to first error. Implement filtering: show all/in-progress/failed/completed tabs. Use memo() for UploadProgressItem to prevent unnecessary re-renders. Monitor performance with React DevTools Profiler ensuring <16ms render time.",
            "status": "pending",
            "testStrategy": "Test with 1000 photos in queue and verify smooth 60 FPS scrolling (use browser DevTools Performance tab). Verify only visible items render (check DOM has ~20 items max). Test scroll-to-failed jumps to correct position. Test filtering tabs show correct subsets. Measure initial render time with React Profiler (<200ms for 1000 items). Test memory usage remains stable during long scrolling sessions."
          },
          {
            "id": 5,
            "title": "Implement main upload page layout with property selector and queue integration",
            "description": "Create /app/upload/page.tsx main upload interface integrating property selector, FileUploadButton, BatchProgress, and virtualized UploadQueue with proper layout and state management",
            "dependencies": [
              1,
              3,
              4
            ],
            "details": "Create /app/upload/page.tsx with layout structure: PropertySelector dropdown at top (fetch from API using useEffect), FileUploadButton below selector, BatchProgress component showing summary stats, UploadQueue taking remaining vertical space. Integrate with Zustand uploadStore: wire FileUploadButton onChange to addPhotosToQueue(), pass queue data to UploadQueue, pass aggregate stats to BatchProgress. Implement property selection requirement: disable upload button if no property selected, show toast prompt. Add 'Start Upload' button to trigger startUpload() action (separate from file selection). Create responsive layout with Tailwind: max-w-7xl container, padding, stack vertically on mobile. Add loading states for property fetching.",
            "status": "pending",
            "testStrategy": "Test page renders all components correctly. Verify property selector loads properties from API. Test file upload disabled until property selected. Test adding 1000 files updates queue and batch progress. Verify 'Start Upload' button triggers upload process. Test responsive layout on mobile, tablet, desktop. Check loading states display during property fetch."
          },
          {
            "id": 6,
            "title": "Add comprehensive error UI (tooltips, modals), success notifications, and Clear Completed functionality",
            "description": "Implement error display mechanisms (hover tooltips, detailed error modals), success completion modal with gallery link, and Clear Completed button to remove successful uploads from queue view",
            "dependencies": [
              5
            ],
            "details": "Create ErrorTooltip.tsx for hover-based error messages on failed items using Radix UI Tooltip or Headless UI. Create ErrorDetailsModal.tsx showing full error stack, retry history, file details (trigger on click). Implement SuccessModal.tsx: show when all uploads complete (completedCount === totalCount && inProgressCount === 0), display success message, show statistics (X photos uploaded in Y minutes), include 'View Gallery' link to /properties/[id]/photos, confetti animation using canvas-confetti. Add 'Clear Completed' button in BatchProgress component: filters out status='complete' items from queue, confirm dialog if 100+ items. Wire modals to Zustand store state. Add toast notifications for critical events (all failed, network offline).",
            "status": "pending",
            "testStrategy": "Test error tooltip appears on hover for failed items. Test error modal opens on click with detailed information. Test success modal appears when all uploads complete. Verify 'View Gallery' link navigates to correct property photos page. Test 'Clear Completed' removes only completed items and shows confirmation for large batches. Test toast notifications trigger for appropriate events. Verify confetti animation plays in success modal."
          }
        ]
      },
      {
        "id": 9,
        "title": "Implement Photo Gallery with Lazy Loading and Full-Size Viewer",
        "description": "Create responsive photo gallery with thumbnail grid, lazy loading, and lightbox modal for full-size viewing",
        "details": "Create components: PhotoGallery.tsx (responsive grid with grid-cols-2 md:grid-cols-3 lg:grid-cols-4), PhotoThumbnail.tsx (lazy-loaded image with loading skeleton, click handler), PhotoLightbox.tsx (modal with full-size image, prev/next navigation, close button, keyboard support). Use Next.js Image component with S3 URLs, enable lazy loading with loading=\"lazy\". Implement intersection observer for progressive loading (load 50 thumbnails initially, load more on scroll). Create /app/properties/[id]/gallery/page.tsx with PhotoGallery displaying photos from usePropertyPhotos hook. Add photo metadata overlay on hover (filename, upload date, file size). Sort photos by uploadedAt DESC. Implement keyboard navigation in lightbox (arrow keys for prev/next, ESC to close). Add loading skeletons for thumbnails and empty state when no photos exist. Optimize image loading with Next.js Image optimizer or CloudFront if available.",
        "testStrategy": "Test gallery loads 1000 photos without performance issues (check FPS and memory usage). Verify lazy loading only loads visible thumbnails initially. Test lightbox opens full-size image and prev/next navigation works. Test keyboard shortcuts (arrows, ESC). Verify responsive layout at mobile, tablet, desktop breakpoints. Test with slow 3G network to ensure progressive loading works. Measure gallery initial load time (should be <2 seconds). Test empty state displays correctly for new properties.",
        "priority": "high",
        "dependencies": [
          5,
          6
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create PhotoGallery component with responsive grid layout and intersection observer",
            "description": "Build the main PhotoGallery component with responsive Tailwind grid (grid-cols-2 md:grid-cols-3 lg:grid-cols-4) and implement intersection observer for progressive loading of thumbnails",
            "dependencies": [],
            "details": "Create /components/PhotoGallery.tsx with responsive grid layout using Tailwind CSS classes. Implement useIntersectionObserver hook to detect when user scrolls near bottom of gallery. Set up state management for photos array, loading state, and hasMore flag. Implement initial load of 50 photos and trigger loading more photos when intersection observer fires. Use usePropertyPhotos hook to fetch photos sorted by uploadedAt DESC. Handle loading states and render PhotoThumbnail components in grid.",
            "status": "pending",
            "testStrategy": "Test responsive layout at mobile (2 columns), tablet (3 columns), and desktop (4 columns) breakpoints. Verify intersection observer triggers when scrolling to bottom. Test initial render loads exactly 50 photos. Check grid layout maintains aspect ratios correctly."
          },
          {
            "id": 2,
            "title": "Implement PhotoThumbnail component with Next.js Image optimization and loading skeletons",
            "description": "Create PhotoThumbnail component that renders lazy-loaded images using Next.js Image component with S3 URLs, loading skeletons, hover metadata overlay, and click handlers",
            "dependencies": [
              1
            ],
            "details": "Create /components/PhotoThumbnail.tsx using Next.js Image component with loading='lazy', sizes prop for responsive images, and S3 URL as src. Implement loading skeleton using Tailwind animate-pulse while image loads. Add hover overlay showing photo metadata (filename, upload date, file size) with absolute positioning and transition effects. Implement onClick handler to open lightbox with selected photo index. Use placeholder='blur' with blurDataURL for better UX. Handle image load errors with fallback UI.",
            "status": "pending",
            "testStrategy": "Verify Next.js Image component correctly optimizes images from S3 URLs. Test loading skeleton appears before image loads. Test hover overlay displays correct metadata (filename, date, size). Verify click handler passes correct photo index to lightbox. Test error handling with invalid image URLs."
          },
          {
            "id": 3,
            "title": "Build PhotoLightbox modal with full-size viewing and prev/next navigation",
            "description": "Create PhotoLightbox modal component that displays full-size images with navigation controls, close button, and smooth transitions between photos",
            "dependencies": [
              1
            ],
            "details": "Create /components/PhotoLightbox.tsx as modal overlay with backdrop. Use Next.js Image component with fill and object-fit contain for full-size images. Implement prev/next navigation buttons with onClick handlers to cycle through photos array. Add close button in top-right corner. Implement state for currentPhotoIndex and isOpen. Add smooth transitions using Tailwind transition classes when switching photos. Prevent body scroll when lightbox is open. Handle edge cases (first/last photo navigation). Use portal for modal rendering.",
            "status": "pending",
            "testStrategy": "Test lightbox opens with correct photo when thumbnail clicked. Verify prev/next buttons cycle through photos correctly. Test close button closes lightbox. Verify first photo disables prev button and last photo disables next button. Test body scroll is prevented when lightbox open. Check image loads at full resolution."
          },
          {
            "id": 4,
            "title": "Add keyboard event handlers for arrow keys and ESC with metadata overlays",
            "description": "Implement keyboard navigation support in PhotoLightbox (arrow keys for prev/next, ESC to close) and enhance metadata display functionality",
            "dependencies": [
              2,
              3
            ],
            "details": "Add useEffect hook in PhotoLightbox to attach keyboard event listeners when modal opens. Implement handlers: ArrowLeft for previous photo, ArrowRight for next photo, Escape to close lightbox. Ensure event listeners are cleaned up on unmount. Add event.preventDefault() to prevent default browser behavior. Enhance metadata overlay in PhotoThumbnail with formatted upload date (use date-fns), human-readable file size (KB/MB), and filename truncation for long names. Add aria-labels for accessibility.",
            "status": "pending",
            "testStrategy": "Test ArrowLeft and ArrowRight keys navigate between photos in lightbox. Verify ESC key closes lightbox. Test keyboard navigation doesn't work when lightbox is closed. Verify metadata overlay shows correctly formatted dates and file sizes. Test with very long filenames to ensure truncation works. Check accessibility with screen readers."
          },
          {
            "id": 5,
            "title": "Implement progressive loading logic and empty state handling",
            "description": "Build progressive loading system that loads 50 photos initially, loads more on scroll, and handles empty states with proper UI feedback",
            "dependencies": [
              1,
              2
            ],
            "details": "Implement loadMore function in PhotoGallery that fetches next batch of photos when intersection observer triggers. Add loading state with spinner at bottom of grid during fetch. Implement hasMore flag to stop loading when all photos fetched. Create empty state component with message and icon when property has no photos. Add error boundary for handling failed photo loads. Implement debouncing on scroll events to prevent excessive API calls. Use React.memo for PhotoThumbnail to prevent unnecessary re-renders. Create /app/properties/[id]/gallery/page.tsx that uses PhotoGallery component.",
            "status": "pending",
            "testStrategy": "Test with property containing 1000 photos and verify only 50 load initially. Monitor network tab to confirm additional batches load on scroll. Verify loading spinner appears during fetch. Test hasMore flag stops loading after all photos loaded. Test empty state displays when property has zero photos. Check performance with React DevTools profiler for unnecessary re-renders."
          }
        ]
      },
      {
        "id": 10,
        "title": "End-to-End Integration Testing and Performance Validation",
        "description": "Implement comprehensive integration tests for complete upload flow and validate performance benchmarks",
        "details": "Create integration test suite using Jest and Playwright: Test 1: Create property → Select 100 photos → Upload → Verify all appear in gallery → Verify count updates. Test 2: Upload 1000 photos → Simulate 5 random failures → Verify auto-retry executes → Manually retry remaining → Verify 100% success. Test 3: Start upload → Refresh browser mid-upload → Verify queue restores from localStorage → Resume upload. Test 4: Test upload cancellation removes photos from queue and stops S3 upload. Create performance tests: Measure upload time for 1000x2MB photos (target <90s on 25Mbps connection). Measure UI frame rate during upload (target 60 FPS). Measure gallery load time for 1000 photos (target <2s). Use Lighthouse to test performance metrics. Create manual testing checklist: Test on Chrome, Safari, Edge. Test on throttled network (3G, 4G). Verify CORS works between frontend and backend. Validate error messages are user-friendly. Create demo script for stakeholder presentation with 1000 sample images.",
        "testStrategy": "Run full integration test suite with `npm run test:e2e`. Verify all tests pass with 100% success rate. Run performance benchmarks and document results (upload time, FPS, load time). Execute manual testing checklist across browsers and network conditions. Create performance report comparing actual vs. target metrics from PRD. Prepare demo environment with sample property and 1000 test images. Validate 99.9% upload success rate requirement is met.",
        "priority": "medium",
        "dependencies": [
          8,
          9
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Playwright test environment with fixtures and test data generation",
            "description": "Configure Playwright testing infrastructure with test fixtures, helpers, and generate 1000 sample test images for comprehensive E2E testing",
            "dependencies": [],
            "details": "Install Playwright and configure playwright.config.ts with baseURL, browser contexts (Chrome, Safari, Edge), and video/screenshot capture. Create tests/fixtures directory with propertyFixture.ts (helper to create test properties), photoFixture.ts (helper to generate test photos), and authFixture.ts (authentication setup). Create tests/helpers/imageGenerator.ts script to generate 1000 sample 2MB JPEG images with unique metadata. Set up tests/helpers/testData.ts with reusable test constants (property names, photo counts). Configure global setup/teardown in playwright.config.ts to seed/clean test database. Create tests/helpers/s3Mock.ts to intercept S3 requests during testing. Set up custom reporter for detailed test results.",
            "status": "pending",
            "testStrategy": "Verify Playwright installation with `npx playwright test --version`. Run sample test to ensure browser launches correctly. Validate test data generation creates exactly 1000 images totaling ~2GB. Verify fixtures can create properties and upload photos successfully."
          },
          {
            "id": 2,
            "title": "Implement end-to-end test: property creation → photo upload → gallery verification",
            "description": "Create comprehensive E2E test that validates complete user flow from property creation through photo upload to gallery display verification",
            "dependencies": [
              1
            ],
            "details": "Create tests/e2e/complete-upload-flow.spec.ts implementing Test 1: Navigate to property creation page → Fill form with property name → Submit and capture propertyId. Use file input to select 100 test photos from generated fixtures → Trigger upload → Wait for all uploads to complete. Navigate to property gallery page → Verify all 100 thumbnails render → Verify photo count displays '100 photos'. Use Playwright's page.waitForSelector() with timeouts for async operations. Capture screenshots at each step for debugging. Implement assertions for: property created successfully (201 response), all upload progress bars reach 100%, gallery grid contains exactly 100 image elements, photo count badge shows correct number. Add test data cleanup in afterEach hook.",
            "status": "pending",
            "testStrategy": "Run test with `npx playwright test complete-upload-flow.spec.ts`. Verify test completes in under 5 minutes. Check screenshots show successful property creation, upload progress, and populated gallery. Verify test passes consistently across 3 consecutive runs."
          },
          {
            "id": 3,
            "title": "Create resilience test: 1000 photo upload with simulated failures and retry validation",
            "description": "Implement stress test uploading 1000 photos with injected network failures to validate auto-retry and manual retry mechanisms achieve 100% success rate",
            "dependencies": [
              1
            ],
            "details": "Create tests/e2e/resilience-test.spec.ts implementing Test 2: Use Playwright route interception with page.route() to simulate 5 random S3 upload failures (return 500 errors). Select 1000 test photos → Start upload → Monitor upload queue state. Verify auto-retry executes for failed uploads (check retry count in uploadStore state). After auto-retry exhausts, manually trigger retry for remaining failures via UI. Poll upload status until all 1000 photos show status='complete'. Assert final success rate is 100% (1000/1000). Track and log: total upload time, number of retries executed, failure distribution. Implement custom Playwright assertions: expect(uploadStore.queue).toHaveSuccessRate(1.0), expect(uploadStore.queue).toHaveNoFailedPhotos(). Use page.evaluate() to access Zustand store state for detailed validation.",
            "status": "pending",
            "testStrategy": "Run test with `npx playwright test resilience-test.spec.ts --workers=1`. Verify exactly 5 failures are injected and all recover. Check test logs show retry attempts for failed uploads. Validate final assertion confirms 1000/1000 success. Run test 3 times to ensure consistent 100% success rate."
          },
          {
            "id": 4,
            "title": "Implement localStorage persistence test with mid-upload browser refresh",
            "description": "Create test validating upload queue state persistence and restoration when browser refreshes during active upload session",
            "dependencies": [
              1
            ],
            "details": "Create tests/e2e/persistence-test.spec.ts implementing Test 3: Start uploading 500 test photos → Wait until ~50% complete (250 uploaded, 250 in queue). Execute page.reload() to simulate browser refresh → Wait for page to fully reload. Verify uploadStore restores from localStorage: check queue contains remaining 250 photos, verify completed photos show status='complete', verify in-progress photos reset to 'queued'. Resume upload by clicking resume button → Wait for all remaining uploads to complete. Assert final state: all 500 photos marked complete, no duplicates uploaded to S3. Implement test helpers: getLocalStorageState() to inspect persisted data, verifyQueueIntegrity() to validate no data corruption. Test edge case: refresh during individual photo upload (verify photo either completes or restarts, no partial uploads).",
            "status": "pending",
            "testStrategy": "Run test with `npx playwright test persistence-test.spec.ts`. Verify localStorage contains expected queue data after refresh. Check browser console for errors during restoration. Validate no duplicate S3 uploads by querying backend for photo count. Test passes if 500 photos upload successfully after refresh."
          },
          {
            "id": 5,
            "title": "Set up performance benchmarks with Lighthouse and custom metrics collection",
            "description": "Implement automated performance testing measuring upload speed, UI frame rate, gallery load time, and Lighthouse scores against defined targets",
            "dependencies": [
              1,
              2
            ],
            "details": "Create tests/performance/benchmarks.spec.ts with three performance tests: (1) Upload Performance Test: Upload 1000x2MB photos using Playwright's network throttling (25Mbps) → Measure total upload time from start to 100% complete → Assert time <90 seconds → Log detailed metrics (photos/sec, MB/sec). (2) UI Performance Test: During active upload, use Playwright's page.evaluate() with requestAnimationFrame() to measure frame times → Calculate average FPS over 30-second window → Assert FPS ≥60 → Track frame drops and jank events. (3) Gallery Load Performance Test: Navigate to property with 1000 photos → Measure time from navigation to last thumbnail visible → Assert load time <2 seconds → Use Performance API to capture LCP, FID, CLS. Install @lhci/cli and create lighthouserc.json config → Run Lighthouse audit on gallery page → Assert performance score ≥90, accessibility ≥95. Export results to JSON for reporting.",
            "status": "pending",
            "testStrategy": "Run performance suite with `npm run test:performance`. Verify upload completes in <90s (may require actual network connection). Check FPS measurements average ≥60 during upload. Validate gallery load time <2s for 1000 photos. Review Lighthouse report for performance score ≥90."
          },
          {
            "id": 6,
            "title": "Create cross-browser test suite with network throttling scenarios",
            "description": "Implement test suite validating upload functionality across Chrome, Safari, Edge browsers under various network conditions including throttled connections",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create tests/e2e/cross-browser.spec.ts using Playwright's project configuration to run tests across chromium, webkit, and firefox browsers. Implement network throttling test matrix: (1) 3G connection (750kbps, 100ms latency) → Upload 50 photos → Verify completion with degraded performance, (2) 4G connection (4Mbps, 50ms latency) → Upload 200 photos → Verify faster completion, (3) Offline → Online transition → Start upload offline → Verify queued state → Go online → Verify upload resumes. Use page.route() to simulate network conditions and CORS scenarios. Create tests/e2e/cors-validation.spec.ts to verify CORS headers on S3 presigned URLs work correctly. Implement error message validation: trigger various failure scenarios (invalid file type, file too large, network error) → Assert user-friendly error messages display (no stack traces, clear actionable text). Configure Playwright to capture video on failure for all browsers.",
            "status": "pending",
            "testStrategy": "Run cross-browser suite with `npx playwright test cross-browser.spec.ts --project=chromium --project=webkit --project=firefox`. Verify tests pass on all three browsers. Test network throttling by checking upload times match expected degradation. Validate CORS by confirming no CORS errors in console logs."
          },
          {
            "id": 7,
            "title": "Document performance results and create stakeholder demo environment with sample images",
            "description": "Generate comprehensive performance report, create demo script with 1000 sample images, and prepare stakeholder presentation materials",
            "dependencies": [
              2,
              3,
              4,
              5,
              6
            ],
            "details": "Create docs/performance-report.md documenting all test results: upload time benchmarks (actual vs target 90s), FPS measurements (actual vs target 60), gallery load time (actual vs target 2s), Lighthouse scores (performance, accessibility, best practices, SEO). Include comparison tables for cross-browser performance and network condition impacts. Generate charts using test result JSON exports. Create demo/README.md with stakeholder demo script: (1) Create new property 'Demo Property', (2) Upload 1000 pre-generated sample images, (3) Show real-time progress tracking, (4) Demonstrate failure recovery by simulating network issue, (5) Navigate to gallery and showcase lazy loading, (6) Open lightbox to show full-size viewing. Set up demo/sample-images directory with 1000 diverse test images (landscapes, portraits, various resolutions). Create demo/demo-script.txt with step-by-step talking points. Record video walkthrough of demo using screen capture. Package everything in demo-package.zip for distribution.",
            "status": "pending",
            "testStrategy": "Review performance-report.md for completeness and accuracy of all metrics. Run through demo script to ensure all steps work smoothly. Verify 1000 sample images are present and diverse. Test demo on clean environment to ensure reproducibility. Share demo package with internal team for feedback before stakeholder presentation."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-11-16T21:29:06.210Z",
      "updated": "2025-11-16T22:24:13.426Z",
      "description": "Tasks for master context"
    }
  }
}